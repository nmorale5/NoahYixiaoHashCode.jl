var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = NoahYixiaoHashCode","category":"page"},{"location":"#NoahYixiaoHashCode","page":"Home","title":"NoahYixiaoHashCode","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for NoahYixiaoHashCode.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using NoahYixiaoHashCode\n\nproblem = load_problem()\nsolution = solve_greedy(problem)\nopen(\"solution_NoahYixiaoHashCode.txt\", \"w\") do f\n    save_text(solution; io=f)\nend","category":"page"},{"location":"#Optimization-Algorithm","page":"Home","title":"Optimization Algorithm","text":"","category":"section"},{"location":"#Problem-and-Notations","page":"Home","title":"Problem and Notations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Suppose we have a city represented by a graph, G = (n s). Here, n = n_i mathrmwhere i = 1 2 dots N_n is a collection of the nodes; s = s_n mathrmwhere n = 1 2 dots N_s is a collection of the streets. N_n and N_s are the numbers of the nodes and streets respectively. Each street, s_n, can be viewed as a tuple, (x_n y_n d_n t_n l_n). Here, x_n and y_n are the two nodes s_n connect; d_n is whether this street is one-way; t_n is the time cost of traversing s_n; l_n is the length of s_n.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this problem, we have multiple cars, the number of which is referred to as N_c, They start from the same initial node. The goal is to maximize the total distance of the the streets that all the cars traverse within a limited time.","category":"page"},{"location":"#Greedy-algorithm","page":"Home","title":"Greedy algorithm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our algorithm is a greedy algorithm. In order to avoid traversing certain streets repeatedly, we store how many times each street has been traversed, which will be referred to as T_n where s_n is the n-th street. At each step, we maximize the heuristic below among all the streets that the car can traverse the next step.","category":"page"},{"location":"","page":"Home","title":"Home","text":"h(s_n)\n= leftbeginarraylrl_n   T_n = 0 \n-t_ntimes T_n  T_n  0 \nendarrayright","category":"page"},{"location":"","page":"Home","title":"Home","text":"If not all the streets have been traversed before, this algorithm maximizes the distance of the next street. If all the streets have been traversed before, this algorithm tries to avoid traversing certain streets over and over again. Actually, h can be any function of l_n, t_n, and T_n. The equation above is just one example that we found easy to calculate and performs well.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that T_n is updated at every step. If we decide to traverse s_n, we need to do T_n = T_n + 1 soon after that. T_n can be larger than 1.","category":"page"},{"location":"#Look-ahead","page":"Home","title":"Look-ahead","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We use a look ahead to improve the greedy algorithm. We sum over the values of the heuristic for a certain number of steps. This is done with a tree search and the time complexity is roughly O(d^L), where d is the average degree of nearby vertices and L is the number of steps to look ahead. Note that the change in T_n due to previous steps is considered in the calculation.","category":"page"},{"location":"#Multiple-cars","page":"Home","title":"Multiple cars","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We schedule the routes for all cars sequentially. First, we use the above algorithm for the first car. After running out of time of the first cat, we start to schedule the route of the second car.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, T_n is shared by all the cars. So, the later cars can also learn from previous cars.","category":"page"},{"location":"#Upper-Bound-Algorithm","page":"Home","title":"Upper Bound Algorithm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To compute our upper bound, we relax one of the rules related to traveling. Normally, at any timestep, cars on a graph G can only travel along one of the streets adjacent to the junction they're currently at.  Instead, we allow cars to travel along any street at any timestep, meaning essentially every junction is connected to every other junction with distance 0 and time cost 0 on a larger graph G.  By doing this, we skip the need for good routing since the street taken no longer affects the possible streets to choose from in the next step.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The maximum distance coverable in G must be at least as much as the maximum distance coverable in G (for the same total amount of time), since G contains all the edges of G and then some.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To find an upper bound on the maximum distance coverable on G, in at most time T, we employ the following algorithm A:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compute the \"efficiency\" of each street as its length divided by its time cost, and sort all streets in an array from greatest to least efficiency.\nSet up running totals for total time and total distance covered, initializing both to 0.\nWhile total time has not yet reached T, pop the next street from the front of the array (the street with the highest efficiency), and add its time and distance to the running totals.\nOnce the total time has met or exceeded T, return the total distance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The total time cost of algorithm A is at least T. Any algorithm B that tries to route the cars following the original rules must take at most time T. This means in order for algorithm B to cover a greater distance, it would need an average efficiency greater than that of algorithm A. However, algorithm A already chooses the maximum possible efficiency, so algorithm B cannot possibly be better.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In conclusion, the algorithm above is a valid upper bound on the maximum possible distance under the original rules. Running the algorithm on the sample Paris data with a maximum time of 18,000 yields an upper bound of 1,525,503.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [NoahYixiaoHashCode]","category":"page"},{"location":"#NoahYixiaoHashCode.Junction","page":"Home","title":"NoahYixiaoHashCode.Junction","text":"Junction\n\nStore the location of a junction.\n\nFields\n\nlat::N: latitude\nlon::N: longitude\n\n\n\n\n\n","category":"type"},{"location":"#NoahYixiaoHashCode.RoutingProblem","page":"Home","title":"NoahYixiaoHashCode.RoutingProblem","text":"RoutingProblem\n\nStore the information of a routing problem.\n\nFields\n\nn_junctions::Int: number of junctions\nn_cars::Int: number of cars\nn_streets::Int: number of streets\ntotal_time::Int: time limit\ninit_j::Int: id of the initial junction\njunctions::J: list of all the Junctions\nstreets::S: list of all the Streets\nsid_matrix::M: a table that shows the indices of streets. It should be a   SparseArrays.SparseMatrixCSC, and sid_matrix[j_end, j_begin] is the   index of the street if it exists otherwise 0.\n\n\n\n\n\n","category":"type"},{"location":"#NoahYixiaoHashCode.Solution","page":"Home","title":"NoahYixiaoHashCode.Solution","text":"Solution\n\nStore a solution to a RoutingProblem\n\nFields\n\nproblem::RoutingProblem: the problem to solve\nroutes: list of junctions that each car visits\n\n\n\n\n\n","category":"type"},{"location":"#NoahYixiaoHashCode.Street","page":"Home","title":"NoahYixiaoHashCode.Street","text":"Street\n\nStore the information of a street.\n\nFields\n\ndistance::D: length\ntime_cost::T: time cost\n\n\n\n\n\n","category":"type"},{"location":"#NoahYixiaoHashCode.distance-Tuple{NoahYixiaoHashCode.Street}","page":"Home","title":"NoahYixiaoHashCode.distance","text":"distance(street)\n\nReturn the length of a Street.\n\n\n\n\n\n","category":"method"},{"location":"#NoahYixiaoHashCode.empty_solution-Tuple{RoutingProblem}","page":"Home","title":"NoahYixiaoHashCode.empty_solution","text":"empty_solution(p::RoutingProblem)\n\nReturn an empty solutoin, in which no car moves.\n\n\n\n\n\n","category":"method"},{"location":"#NoahYixiaoHashCode.is_feasible-Tuple{Solution}","page":"Home","title":"NoahYixiaoHashCode.is_feasible","text":"is_feasible(solution::Solution)\n\nReturn whether a Solution is feasible.\n\n\n\n\n\n","category":"method"},{"location":"#NoahYixiaoHashCode.load_problem","page":"Home","title":"NoahYixiaoHashCode.load_problem","text":"load_problem(problem_input=normpath(joinpath(@__DIR__, \"..\", \"data\", \"paris_54000.txt\")))\n\nReturn a RoutingProblem defined by the input file.\n\n\n\n\n\n","category":"function"},{"location":"#NoahYixiaoHashCode.save_text-Tuple{Solution}","page":"Home","title":"NoahYixiaoHashCode.save_text","text":"save_text(solution::Solution; io=stdout)\n\nWrite the solution in the text format to io.\n\n\n\n\n\n","category":"method"},{"location":"#NoahYixiaoHashCode.solve_greedy-Tuple{RoutingProblem}","page":"Home","title":"NoahYixiaoHashCode.solve_greedy","text":"solve_greedy(problem::RoutingProblem; search_depth = 10)\n\nSolve a RoutingProblem using a greedy algorithm.\n\nArguments\n\nproblem: the RoutingProblem to solve\nsearch_depth: the number of steps for the look-ahead. When it is 1,   the code uses a greedy algorithm without a look-ahead.\n\n\n\n\n\n","category":"method"},{"location":"#NoahYixiaoHashCode.time_cost-Tuple{NoahYixiaoHashCode.Street}","page":"Home","title":"NoahYixiaoHashCode.time_cost","text":"time_cost(street)\n\nReturn the time cost of traversing a Street.\n\n\n\n\n\n","category":"method"},{"location":"#NoahYixiaoHashCode.total_distance-Tuple{Solution}","page":"Home","title":"NoahYixiaoHashCode.total_distance","text":"total_distance(solution::Solution; check=true)\n\nReturn the total distance achieved by a solution.\n\n\n\n\n\n","category":"method"},{"location":"#NoahYixiaoHashCode.total_distance_upper_bound-Tuple{RoutingProblem}","page":"Home","title":"NoahYixiaoHashCode.total_distance_upper_bound","text":"total_distance_upper_bound(problem::RoutingProblem)\n\nCompute an upper bound on the given RoutingProblem following the algorithm descibed in upper_bound_doc.md\n\n\n\n\n\n","category":"method"}]
}
